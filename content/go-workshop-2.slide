Go Workshop - Dia 2
https://golang-workshop.io
Tags: golang

Rodolfo Finochietti
[[https://rodolfofinochietti.me]]
@rodolfof

Mariano Sánchez
@marianosz

* Linea de comandos - Argumentos

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/11-cmdline][Ejercicio 11]]

.code -numbers ./resources/src/cmdline-args.go

* Linea de comandos - Flags

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/11-cmdline][Ejercicio 11]]

.code -numbers ./resources/src/cmdline-flags.go

* Linea de comandos - Variables de entorno

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/11-cmdline][Ejercicio 11]]

.code -numbers ./resources/src/cmdline-env.go

* Testing

- Golang posee un framework de testing incluido en la standard library.
- Se encuentra en el paquete _testing_.
- Todo archivo Go con el sujifo *_test.go* es considerado un test suite en Golang.
- En cada test suite podemos correr:
	Unit Tests
	Benchmarks
	Examples

* Testing - Unit Test

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/12-testing][Ejercicio 12]]

.code -numbers ./resources/src/test.go

- Cada funcion TestXxxx en un test suite es un unit test.
- El comando *go* *test* corre los test del proyecto.

* Testing - Code Coverage

Se puede controlar el code coverage con el comando:

	$ go test -cover

Se pueden exportar los resultados y verlos en html con:

	$ go test -coverprofile=coverage.out
	$ go tool cover -html=coverage.out

* Testing - Benchmark

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/12-testing][Ejercicio 12]]

.code -numbers ./resources/src/test-benchmark.go

- Cada funcion BenchmarkXxxx es un benchmark.
- Un Benchmark no es un test.
- Las funciones de benchmark son ejecutadas muchas veces por el framework de test.
- El valor *b.N* se incrementa hasta que el framework el test esta safisfecho de la estabilidad del benchmark.

* Testing - Benchmark

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/12-testing][Ejercicio 12]]

Un benchmark se ejecuta con el comando *go* *test* *-bench=.* (el parametro _bench_ es _regex_ para indicar cuales benchmarks queremos correr).

El resultado es:

	$ go test -bench=.
	PASS
	BenchmarkFibonacci   5000000               509 ns/op
	ok      github.com/rfinochi/golang-workshop       3.084s

La segunda linea indica el valor final de *b.N* y el tiempo promedio de ejecucion en nanosegundos/operacion.

* Testing - Benchmark

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/12-testing][Ejercicio 12]]

.code -numbers ./resources/src/test-benchmark-wrong.go

Un loop es un operacion crucial en un benchmark, *cuidado!*

* Testing - Example

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/12-testing][Ejercicio 12]]

.code -numbers ./resources/src/test-example.go

- Los _examples_ son snippets de codigo Golang que se muestran como parte de la documentacion.
- Estan verificados por que tambien se corren como tests. 
- Tambien se pueden ejecutar por el usuario al leer la documentacion web generada con la herramienta _godoc_ (el usuario dispone de un boton _Run_ _Test_).

* Structs

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/13-structs][Ejercicio 13]]

- Coleccion de campos tipados.
- Pueden contener metodos.
- Pero no son clases estrictamente hablando.

Golang favorece la composicion por sobre la herencia:

- [[https://en.wikipedia.org/wiki/Structural_type_system][Structural Typing]]: Como Duck Typing pero en tiempo de compilacion.

- Embedding: [[https://en.wikipedia.org/wiki/Fragile_base_class][The fragile base class problem]].

.code ./resources/src/structs.go

* Structs anidados

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/13-structs][Ejercicio 13]]

.code ./resources/src/structs-nested.go

* Structs - Metodos

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/13-structs][Ejercicio 13]]

Un metodo no es mas que una funcion con un argumento receptor especial

.code ./resources/src/structs-methods.go

* Punteros

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/13-structs][Ejercicio 13]]

- Golang soporta punteros para actualizar valores pero no admite aritmetica de punteros como en C. 
- *** se usa como prefijo para definir un puntero para de un tipo dado.

.code ./resources/src/structs-pointers.go

* Structs compuestos

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/13-structs][Ejercicio 13]]

[[http://blog.ralch.com/tutorial/design-patterns/golang-composite/][Composition Design Pattern]]

.code ./resources/src/structs-composed.go

* Interfaces

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/14-interfaces][Ejercicio 14]]

- El feature mas importante del lenguaje segun Rob Pike.
- Extensamente usadas en la standard library.
- Es una manera de soportar metodos genericos.
- Se puede hacer composicion de interfaces.
- *No* *es* *necesario* *de* *implementarlas* *explicitamente*.

Lo mas importante de las interfaces es la cultura detras de ellas, piezas de codigo chicas que abstraen funcionalidades.

- "Be conservative in what you send, be liberal in what you accept"
- "The bigger the interface, the smallest the abstraction"

[[https://youtu.be/F4wUrj6pmSI][Understanding Go Interfaces]]

* Interfaces values

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/14-interfaces/interface-values.go][Ejemplo]]

Los valores de la interfaz pueden considerarse como una tupla de un valor y un tipo concreto, esto se llaman _interface_ _value_:

	(value, type)

- Un _interface_ _value_ contiene un valor de un tipo concreto subyacente especifico.
- Llamar a un metodo en un _interface_ _value_ ejecuta el metodo del mismo nombre en su tipo subyacente.

* The empty interface

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/14-interfaces/empty-interface.go.go][Ejemplo]]

Una interfaz sin metodos se conoce como interfaz vacia:

	interface{}

- Una interfaz vacia puede contener valores de cualquier tipo.
- Las interfaces vacias se usan en codigo que tiene que trabajar con valores de un tipo desconocido. Por ejemplo, _fmt.Print_ recibe argumentos de tipo _interface{}_.

* Type assertions

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/14-interfaces/type-assertions.go][Ejemplo]]

El mecanismo de _type_ _assertion_ provee acceso a los valores concretos de un _interface_ _value_:

	t := i.(T)

La instruccion anterior comprueba que el _interface_ _value_ i contiene el tipo concreto T y asigna el valor a la variable t.

Para comprobar que una interfaz almacena un tipo especifico se usa:

	t, ok := i.(T)

* Type switches

Un _type_ _switch_ es un mecanismo que permite hacer _type_ _assertions_ en serie:

	switch v := i.(type) {
	case T:
		// here v has type T
	case S:
		// here v has type S
	default:
		// no match; here v has the same type as i
	}

* Creacion de tipos - make

- Funcion built-in que se usa unicamente para alocar e inicializar slices, maps o channels.
- Se indica el tipo, el tama�o y la capacidad.
- Como resultado obtenemos la variable en si, no un puntero.

	slice := make([]int, 0, 10)

* Creacion de tipos - new

- Funcion built-in que se usa para alocar memoria.
- Retorna un puntero al valor.

	type Person struct {
		Name string
		Age  int
	}
	juan := new(Person)

* Creacion de tipos - Struct Types

	var juan Person
	rect.Name = "Juan"
	rect.Age = 40

* Creacion de tipos - Struct Literal y &

La inicializacion implicita mas el _&_ es equivalente a _new_.

	juan := Person{"Juan", 22}
	juanPointer := &Person{Name: "Juan", Age: 22}

* Error Handling

El manejo de excepciones es una de las caracteristicas mas controversiales en Golang.

.image ./resources/images/error-handling.jpg 450 _

* Error Handling

- Los errores en Golang *no* *son* excepciones.
- Por convencion, si una funcion puede fallar deber retornar un tipo _error_.
- El tipo _error_ contiene la infomacion del problema.
- Si es _nil_ quiere decir que no hubo errores

	func calculate(a, b int) (int, error) { }

	result, err := caculate(a, b)
	if err != nil {
		// handle the error
	}
	// continue

: https://medium.com/gett-engineering/error-handling-in-go-53b8a7112d04

* Defer

- Una declaracion _defer_ guarda la llamada a la funcion en una lista.
- La lista de llamadas guardadas se ejecuta despues de que la funcion circundante termina.
- _defer_ se usa comunmente para simplificar acciones de limpieza.

	func CopyFile(dstName, srcName string) (written int64, err error) {
		src, err := os.Open(srcName)
		if err != nil {
			return
		}
		defer src.Close()

		dst, err := os.Create(dstName)
		if err != nil {
			return
		}
		defer dst.Close()

		return io.Copy(dst, src)
	}

: https://blog.golang.org/defer-panic-and-recover

* Panic y Recover

- *panic* que detiene el flujo de control ordinario y comienza un proceso de panico (_panicking_).
- Cuando la funcion F llama a _panic_, la ejecucion de F se detiene, las funciones diferidas en F se ejecutan normalmente y luego F vuelve a su llamador. 
- Para el llamador, F se comporta como una llamada al panico, y vuelve a su llamador
- El proceso continua hasta que todas las funciones retornan, momento en el cual el programa falla.
- *recover* recupera el control de una funcion en panico. 
- La recuperacion solo es util dentro de las funciones diferidas.
- Durante la ejecucion normal, una llamada a recuperar devolvera nulo y no tendra otro efecto. 
- Si la funcion actual esta en panico, una llamada a recuperar capturara el valor que se especifico al crear el panico y reanudara la ejecucion normal.

* Panic y Recover

.caption [[https://github.com/rfinochi/golang-workshop-src/tree/master/15-defer-panic-recover/main.go][Ejemplo]]

- "Errors are values."
- "Don't just check errors, handle them gracefully."
- "Don't panic."

All of Rob Pike's [[https://go-proverbs.github.io/][Go Proverbs]]

* Review time

.image ./resources/images/review-time.png 500 _

* Challenge 2.1

.image ./resources/images/chalenge-accepted.jpg 150 _

Cambiar el programa para que el parametro string de la funcion _Reverse_ se obtenga desde la linea de comandos con un flag llamado _text_.

* Challenge 2.2

.image ./resources/images/chalenge-accepted.jpg 150 _

Crear un _unit_ _test_, un _benchmark_, y un _example_ para la funcion _Reverse_.

* Challenge 2.3

.image ./resources/images/chalenge-accepted.jpg 150 _

Modelar la funcionalidad de un sistema de precios para una aerolinea que calcule los ingresos netos de un vuelo en base a los pasajeros y el precio base del ticket.

El precio base del ticket es el mismo para todos los pasajeros.

Existen 3 tipos de pasajeros:

- Base: Paga el 100% del precio base.
- De ultimo minuto: Paga el 50% del precio base.
- Empleado de la aerolinea: No paga el ticket.

* Challenge 2.4

.image ./resources/images/chalenge-accepted.jpg 150 _

Crear un _test_ para verificar el codigo creado en el challenge 2.1 anterior.

* Challenge 2.5

.image ./resources/images/chalenge-accepted.jpg 150 _

Agregar un nuevo tipo de pasajero 'empleado de aerolinea de ultimo minuto' cuyo descuento sea la suma de los descuentos de los tipos de pasajero 'empleado de aerolinea' y 'ultimo minuto'.